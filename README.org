* 6. ZigZag Conversion                           :array:string:tooMuchMemory:

** solution 1

用额外 O(n) 空间，内存使用大：Memory Usage: 14.2 MB, less than 5.34% of Python3 

#+BEGIN_SRC python
  class Solution:
      def convert(self, s: str, numRows: int) -> str:
	  if numRows == 1:
	      return s

	  res = []
	  for i in range(0, len(s), numRows*2-2):
	      res.append(s[i])

	  for d in range(1, numRows-1):
	      i = d
	      while True:
		  n = i + numRows*2-2

		  if i < len(s):
		      res.append(s[i])

		  if n-2*d < len(s):
		      res.append(s[n-2*d])
		  else:
		      break

		  i = n

	  for i in range(numRows - 1, len(s), numRows*2-2):
	      res.append(s[i])
	  return ''.join(res)

#+END_SRC


** solution 2

同上，细节略有不同，Memory Usage: 14.3 MB, less than 5.34% of Python3 

#+BEGIN_SRC python
  class Solution:
      def convert(self, s: str, numRows: int) -> str:
	  if numRows == 1:
	      return s

	  res = ""
	  n = numRows*2-2
	  t = list(range(0, len(s), n))
	  for i in range(0, numRows):
	      for c in t:
		  if c + i < len(s):
		      res += s[c+i]

		  if i > 0 and i < numRows-1 and c+n-i < len(s):
		      res += s[c+n-i]

	  return res
#+END_SRC



** solution 3.

按行来保存结果，遍历字符串相当于往 row0, row1, row2, ..., rowN, rowN-1, ..., row1, row0, row1, row2, ... 追加数据

#+BEGIN_SRC python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s

        rows = ["" for _ in range(numRows)]
        n = numRows*2-2
        for i, c in enumerate(s):
            t = i % n
            if t >= numRows:
                t = n - t
            rows[t] += c

        return ''.join(rows)
#+END_SRC

速度比之前的快，但内存使用依然不小 Memory Usage: 14.2 MB, less than 5.34% of Python3 


* 40. Combination Sum II                              :array:recurse:notfast:

递归解法，分治。问题可以简化为求从 cs[x:] 选择元素，使其和为 sum

不够快：faster than 65.04% of Python3 

#+BEGIN_SRC python
  class Solution:
      def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
	  cs = sorted(c for c in candidates if c <= target)

	  def solve(x, t):
	      if x >= len(cs) or cs[x] > t:
		  return []

	      if cs[x] == t:
		  return [f'{cs[x]}']

	      res = [f'{cs[x]},{subres}' for subres in solve(x+1, t-cs[x])]
	      res.extend(solve(x+1, t))
	      return res

	  return list(map(
		  lambda l: [int(v) for v in l],
		  (r.split(',') for r in set(solve(0, target))))
		  )
#+END_SRC

* 41. First Missing Positive                                     :array:sort:

** solution 1. sort

排序后从前往后遍历，不够快 faster than 59.59% of Python3

#+BEGIN_SRC python
  class Solution:
      def firstMissingPositive(self, nums: List[int]) -> int:
	  ss = sorted(x for x in nums if x > 0)
	  if len(ss) == 0:
	      return 1
	  n = 1
	  i = 0
	  while i < len(ss):
	      if ss[i] != n:
		  return n

	      i += 1
	      while i < len(ss) and ss[i] == n:
		  i+=1

	      n += 1
	  return n
#+END_SRC


** solution 2. hash table with array

更慢 faster than 8.26% of Python3

#+BEGIN_SRC python
  class Solution:
      def firstMissingPositive(self, nums: List[int]) -> int:
	  marks = [0 for _ in range(len(nums))]
	  for n in nums:
	      if n < 1 or n > len(marks):
		  continue
	      marks[n-1] = 1
	  for i, m in enumerate(marks):
	      if m != 1:
		  return i+1
	  return len(marks)+1
#+END_SRC

** solution 3. swap in place

依旧不够快：faster than 59.59% of Python3 

#+BEGIN_SRC python
  class Solution:
      def firstMissingPositive(self, nums: List[int]) -> int:
	  def replace(idx):
	      v = nums[idx]
	      if v >= 1 and v < len(nums) and nums[v-1] != v:
		  nums[v-1], nums[idx] = nums[idx], nums[v-1]
		  replace(idx)

	  for i in range(len(nums)):
	      replace(i)

	  for i, v in enumerate(nums):
	      if i+1 != v:
		  return i+1
	  return len(nums)+1
#+END_SRC

可能是递归有额外开销，使用循环重构之，依然不够快，可能与 python runtime 有关 faster than 59.59% of Python3

#+BEGIN_SRC python
  class Solution:
      def firstMissingPositive(self, nums: List[int]) -> int:
	  for i in range(len(nums)):
	      j = i
	      while nums[j] >= 1 and nums[j] < len(nums) and nums[nums[j]-1] != nums[j]:
		  nums[nums[j]-1], nums[j] = nums[j], nums[nums[j]-1]
                                   
	  for i, v in enumerate(nums):
	      if i+1 != v:
		  return i+1
	  return len(nums)+1
#+END_SRC

* 55. Jump Game                                        :array:badPerformance:

** 解法一

用位图标记下一轮可能的位置，直到所有可能结果都被走完

可以优化，当最后一位变为 true，则直接返回 true

#+BEGIN_SRC go
  func canJump(nums []int) bool {
	  marks := make([]bool, len(nums))
	  targets := []int{0}

	  for {
		  temp := []int{}
		  for _, idx := range targets {
			  for i := idx; i < nums[idx]+idx+1 && i < len(nums); i++ {
				  if !marks[i] {
					  marks[i] = true
					  temp = append(temp, i)  
                                        
					  if i == len(nums)-1 && marks[i] {
						  return true
					  }                             
				  }                                                 
			  }                                                         
		  }                                                                 

		  if len(temp) == 0 {
			  break
		  }

		  targets = temp
	  }

	  return false
  }
#+END_SRC
* 56. Merge Intervals                                         :array:segment:

维护一个严格排序的 interval 数组 ss，往后面插入新的 interval。新的 interval 有三种情况（提前已经排好序）
1. 被 ss[-1] 包含
2. 延长 ss[-1]
3. 与 ss[-1] 不重叠

#+BEGIN_SRC python
  class Solution:                 
      def merge(self, intervals: List[List[int]]) -> List[List[int]]:
	  if len(intervals) == 0:
	      return []
	  ss = sorted(intervals, key=lambda p: p[0])
	  res = [ss[0]]         
	  for s in ss[1:]:      
	      # case 1: merge
	      # XXXXXXX
	      #   XXX
	      if res[-1][1] >= s[1]:
		  pass
	      # case 2:
	      # XXXXXXX
	      #           XXX
	      elif res[-1][1] < s[0]:
		  res.append(s)
	      # case 3:
	      # XXXXXXX
	      #     XXXXXX
	      else:
		  res[-1][1] = s[1]
	  return res
#+END_SRC
* 57. Insert Intervals                                :array:segment:notfast:

** solution 1.

同 56 解法，但不够快: faster than 51.50% of Python3

#+BEGIN_SRC python
  class Solution:
      def insert(self, segments: List[List[int]], newInterval: List[int]) -> List[List[int]]:     
	  if len(segments) == 0:   
	      return [newInterval]

	  ss = sorted(segments + [newInterval], key=lambda p: p[0])
	  res = [ss[0]]           
	  for s in ss[1:]:        
	      if res[-1][1] >= s[1]:  
		  pass  
	      elif res[-1][1] < s[0]:  
		  res.append(s)  
	      else:  
		  res[-1][1] = s[1]  
	  return res  
#+END_SRC

** solution 2.

优化 solution 1，在 newInterval 左边和右边的 segments 不用参与合并和插入

结果 faster than 84.95% of Python3

#+BEGIN_SRC python
  class Solution:
      def insert(self, segments: List[List[int]], newInterval: List[int]) -> List[List[int]]:
	  if len(segments) == 0:
	      return [newInterval]

	  # the left and right segments can be saved without insert
	  x, y = 0, len(segments)
	  for i, seg in enumerate(segments):
	      # seg
	      #       newInterval
	      if seg[1] < newInterval[0]:
		  x = i+1

	      # the first segement at the right of the interval
	      #             seg
	      # newInterval
	      if seg[0] > newInterval[1]:
		  y = i
		  break

	  ss = sorted(segments[x:y] + [newInterval], key=lambda p: p[0])
	  res = [ss[0]]         
	  for s in ss[1:]:      
	      if res[-1][1] >= s[1]:
		  pass
	      elif res[-1][1] < s[0]:
		  res.append(s)
	      else:
		  res[-1][1] = s[1]
	  return segments[:x] + res + segments[y:]
#+END_SRC
