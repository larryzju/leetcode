* 40. Combination Sum II :array:recurse:notfast:

递归解法，分治。问题可以简化为求从 cs[x:] 选择元素，使其和为 sum

不够快：faster than 65.04% of Python3 

#+BEGIN_SRC python
  class Solution:
      def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
	  cs = sorted(c for c in candidates if c <= target)

	  def solve(x, t):
	      if x >= len(cs) or cs[x] > t:
		  return []

	      if cs[x] == t:
		  return [f'{cs[x]}']

	      res = [f'{cs[x]},{subres}' for subres in solve(x+1, t-cs[x])]
	      res.extend(solve(x+1, t))
	      return res

	  return list(map(
		  lambda l: [int(v) for v in l],
		  (r.split(',') for r in set(solve(0, target))))
		  )
#+END_SRC


* 55. Jump Game                                        :array:badPerformance:

** 解法一

用位图标记下一轮可能的位置，直到所有可能结果都被走完

可以优化，当最后一位变为 true，则直接返回 true

#+BEGIN_SRC go
  func canJump(nums []int) bool {
	  marks := make([]bool, len(nums))
	  targets := []int{0}

	  for {
		  temp := []int{}
		  for _, idx := range targets {
			  for i := idx; i < nums[idx]+idx+1 && i < len(nums); i++ {
				  if !marks[i] {
					  marks[i] = true
					  temp = append(temp, i)  
                                        
					  if i == len(nums)-1 && marks[i] {
						  return true
					  }                             
				  }                                                 
			  }                                                         
		  }                                                                 

		  if len(temp) == 0 {
			  break
		  }

		  targets = temp
	  }

	  return false
  }
#+END_SRC
* 56. Merge Intervals                                         :array:segment:

维护一个严格排序的 interval 数组 ss，往后面插入新的 interval。新的 interval 有三种情况（提前已经排好序）
1. 被 ss[-1] 包含
2. 延长 ss[-1]
3. 与 ss[-1] 不重叠

#+BEGIN_SRC python
  class Solution:                 
      def merge(self, intervals: List[List[int]]) -> List[List[int]]:
	  if len(intervals) == 0:
	      return []
	  ss = sorted(intervals, key=lambda p: p[0])
	  res = [ss[0]]         
	  for s in ss[1:]:      
	      # case 1: merge
	      # XXXXXXX
	      #   XXX
	      if res[-1][1] >= s[1]:
		  pass
	      # case 2:
	      # XXXXXXX
	      #           XXX
	      elif res[-1][1] < s[0]:
		  res.append(s)
	      # case 3:
	      # XXXXXXX
	      #     XXXXXX
	      else:
		  res[-1][1] = s[1]
	  return res
#+END_SRC
* 57. Insert Intervals                                :array:segment:notfast:

** solution 1.

同 56 解法，但不够快: faster than 51.50% of Python3

#+BEGIN_SRC python
  class Solution:
      def insert(self, segments: List[List[int]], newInterval: List[int]) -> List[List[int]]:     
	  if len(segments) == 0:   
	      return [newInterval]

	  ss = sorted(segments + [newInterval], key=lambda p: p[0])
	  res = [ss[0]]           
	  for s in ss[1:]:        
	      if res[-1][1] >= s[1]:  
		  pass  
	      elif res[-1][1] < s[0]:  
		  res.append(s)  
	      else:  
		  res[-1][1] = s[1]  
	  return res  
#+END_SRC

** solution 2.

优化 solution 1，在 newInterval 左边和右边的 segments 不用参与合并和插入

结果 faster than 84.95% of Python3

#+BEGIN_SRC python
  class Solution:
      def insert(self, segments: List[List[int]], newInterval: List[int]) -> List[List[int]]:
	  if len(segments) == 0:
	      return [newInterval]

	  # the left and right segments can be saved without insert
	  x, y = 0, len(segments)
	  for i, seg in enumerate(segments):
	      # seg
	      #       newInterval
	      if seg[1] < newInterval[0]:
		  x = i+1

	      # the first segement at the right of the interval
	      #             seg
	      # newInterval
	      if seg[0] > newInterval[1]:
		  y = i
		  break

	  ss = sorted(segments[x:y] + [newInterval], key=lambda p: p[0])
	  res = [ss[0]]         
	  for s in ss[1:]:      
	      if res[-1][1] >= s[1]:
		  pass
	      elif res[-1][1] < s[0]:
		  res.append(s)
	      else:
		  res[-1][1] = s[1]
	  return segments[:x] + res + segments[y:]
#+END_SRC
