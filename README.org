* 55. Jump Game                                        :array:badPerformance:

** 解法一

用位图标记下一轮可能的位置，直到所有可能结果都被走完

可以优化，当最后一位变为 true，则直接返回 true

#+BEGIN_SRC go
  func canJump(nums []int) bool {
	  marks := make([]bool, len(nums))
	  targets := []int{0}

	  for {
		  temp := []int{}
		  for _, idx := range targets {
			  for i := idx; i < nums[idx]+idx+1 && i < len(nums); i++ {
				  if !marks[i] {
					  marks[i] = true
					  temp = append(temp, i)  
                                        
					  if i == len(nums)-1 && marks[i] {
						  return true
					  }                             
				  }                                                 
			  }                                                         
		  }                                                                 

		  if len(temp) == 0 {
			  break
		  }

		  targets = temp
	  }

	  return false
  }
#+END_SRC
* 56. Merge Intervals                                         :array:segment:

维护一个严格排序的 interval 数组 ss，往后面插入新的 interval。新的 interval 有三种情况（提前已经排好序）
1. 被 ss[-1] 包含
2. 延长 ss[-1]
3. 与 ss[-1] 不重叠

#+BEGIN_SRC python
  class Solution:                 
      def merge(self, intervals: List[List[int]]) -> List[List[int]]:
	  if len(intervals) == 0:
	      return []
	  ss = sorted(intervals, key=lambda p: p[0])
	  res = [ss[0]]         
	  for s in ss[1:]:      
	      # case 1: merge
	      # XXXXXXX
	      #   XXX
	      if res[-1][1] >= s[1]:
		  pass
	      # case 2:
	      # XXXXXXX
	      #           XXX
	      elif res[-1][1] < s[0]:
		  res.append(s)
	      # case 3:
	      # XXXXXXX
	      #     XXXXXX
	      else:
		  res[-1][1] = s[1]
	  return res
#+END_SRC
* 57. Insert Intervals                                :array:segment:notfast:

同 56 解法，但不够快: faster than 51.50% of Python3

#+BEGIN_SRC python
  class Solution:
      def insert(self, segments: List[List[int]], newInterval: List[int]) -> List[List[int]]:     
	  if len(segments) == 0:   
	      return [newInterval]

	  ss = sorted(segments + [newInterval], key=lambda p: p[0])
	  res = [ss[0]]           
	  for s in ss[1:]:        
	      if res[-1][1] >= s[1]:  
		  pass  
	      elif res[-1][1] < s[0]:  
		  res.append(s)  
	      else:  
		  res[-1][1] = s[1]  
	  return res  
#+END_SRC
